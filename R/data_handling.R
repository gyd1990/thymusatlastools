## ------------------------------------------------------------------------

#' Export raw and normalized data from a Seurat object.
#'
#' @export
export_from_seurat = function( dge, results_path, name, 
                               metadata_included = c( "nGene", "nUMI", "orig.ident", "eday", "IG1.S", "S", "G2.M", "M", "M.G1" ) ){
  desired_metadata = dge@data.info[, metadata_included ]
  raw_dge = deseuratify_raw_data( dge )
  desired_total = normalize_cpx_amt( raw_dge, results_path, do.plot = F )
  normalized_dge = apply(raw_dge, 2, div_by_sum)*desired_total
  write.table( raw_dge,          file.path( results_path, paste0( name, "_counts_raw.data" ) ), 
               row.names = T, col.names = T, quote = F, sep = "\t" )
  write.table( normalized_dge,   file.path( results_path, paste0( name, "_counts_scaled.data" ) ), 
               row.names = T, col.names = T, quote = F, sep = "\t" )
  write.table( desired_metadata, file.path( results_path, paste0( name, "_metadata.data" ) ), 
               row.names = T, col.names = T, quote = F, sep = "\t" )
}


#' Rescale every cell to a certain amount of UMIs, where
#' that amount is selected by rounding up the median UMI count up to the next power of 10.
#'
#'@export
normalize_cpx_amt = function(dge, results_path = NULL ){

  umis_by_cell = apply( dge, 2, sum )
  assertthat::are_equal(length(umis_by_cell), length(colnames(dge)))
  magnitude = umis_by_cell %>% median %>% log10 %>% ceiling
  to.return = 10^magnitude 
  
  # # Plot results
  if( !is.null(results_path) ){
      dir.create.nice( file.path( results_path, "QC" ) )
    pdf( file.path( results_path, "QC", "total_umis_by_cell.pdf"))
    {
      hist(log10(umis_by_cell), breaks = 40,
           xlab = "log10 UMI count", main = "Number of UMIs by cell")
      abline(v = to.return)
    }
    dev.off()
  }
  
  return(to.return)
}
demo1 = matrix(2000, nrow = 5, ncol = 3)
assertthat::are_equal(normalize_cpx_amt(demo1, results_path = NULL), 10000)


#' Make arrays into Seurat objects.
#' 
#' Keeps all genes expressed in at least
#' (by default) 3 cells and keeps all cells with at least 1000 genes. It reports some 
#' summary figures, plotting number of genes by cell, num UMIs by cell, and number of cells by
#' gene. 
#'@export
seuratify_thy_data = function(raw_dge, results_path = NULL, test_mode = F, 
                              min.genes = 1000, min.cells = 3 ){
  atat(1 < raw_dge %>% dim %>% min %>% min)

  total_desired = normalize_cpx_amt( raw_dge, results_path )
  raw_dge_norm = apply( X = raw_dge, MARGIN = 2, FUN = div_by_sum ) * total_desired
  raw_dge_norm = as( raw_dge_norm, "sparseMatrix" )
  seurat_dge = Setup( new( "seurat", raw.data = log2( 1+raw_dge_norm ) ),
                      min.cells = min.cells * (1 - test_mode), # 0 if test_mode; else 3
                      min.genes = min.genes * (1 - test_mode), # 0 if test_mode; else min.genes
                      is.expr=0, 
                      do.logNormalize = F, 
                      project = "thymus_scRNAseq", 
                      names.delim = "\\|",
                      names.field = 2 )
  
  # # Make sure the raw data is just UMI counts and update the nUMI field, which will be
  # # filled incorrectly given the above
  seurat_dge@raw.data = raw_dge[ seurat_dge@data %>% rownames, 
                                 seurat_dge@data %>% colnames ]
  seurat_dge %<>% AddMetaData( col.name = "nUMI", 
                               metadata = setNames( colSums( seurat_dge@raw.data ),
                                                    colnames( seurat_dge@raw.data ) ) )
  
  # # Plot results
  if( !is.null( results_path ) ){
    dir.create.nice( file.path(results_path, "QC" ) )
    genes_by_cell = apply( raw_dge, 2, nnz )
    atat( length( genes_by_cell ) == ncol( raw_dge ) ) # num cells = num cols
    {
      pdf(file.path(results_path, "QC", "total_genes_by_cell.pdf"))
      hist(log10(genes_by_cell), breaks = 40,
           xlab = "log10 gene count", main = "Number of genes by cell")
      abline(v = log10( min.genes ) )
      dev.off()
    }
    
    cells_by_gene = apply( raw_dge, 1, nnz )
    atat( length( cells_by_gene ) == nrow( raw_dge )[1] ) # num genes = num rows
    {
      pdf(file.path(results_path, "QC", "total_cells_by_gene.pdf"))
      hist(log10(cells_by_gene), breaks = 40,
           xlab = "log10 cell count", main = "Number of cells by gene")
      abline(v = log10( min.cells ) )
      dev.off()
    }
    
    print( paste0("There are ", 
                  length(cells_by_gene), " genes and ", 
                  length(genes_by_cell), " cells in the raw data."))
    print( paste0( length( cells_by_gene ) - nrow( seurat_dge@data ), " genes and ", 
                   length( genes_by_cell ) - ncol( seurat_dge@data ), " cells were excluded from the Seurat object."))
    
  }

  return(seurat_dge)
}


#' Extract mostly-raw (medium rare?) data from a Seurat object.
#' 
#' Seurat preserves the raw data exactly. Sometimes that's not ideal.
#' This function helps you get rawish data that have undergone the same QC filters as the Seurat scale.data,
#' so some cells and genes are filtered out. 
#' But, the numbers are UMI counts, integers, not logged or with any of that normalization BS.
#' This function guarantees output with `colnames(output) == dge@cell.names`.
#' 
#' Because the `@raw.data` slot was filled in wrong in some of my Seurat objects,
#' this can use `load_thymus_profiling_data` to get the raw data.
#' To toggle this behavior, set `retrieve_anew = {T,F}`.
#'@export
deseuratify_raw_data = function( seurat_dge, retrieve_anew = F ){
  if( !retrieve_anew ){
    raw_dge = seurat_dge@raw.data
  } else {
    raw_dge = load_thymus_profiling_data( sample_ids = unique( FetchData(seurat_dge, "orig.ident" )[[1]]) ) %>% dge_merge_list
  }
  desired_genes = rownames( seurat_dge@scale.data )
  acceptable_genes = intersect( desired_genes, rownames( raw_dge ) )
  missing_genes    = setdiff(   desired_genes, rownames( raw_dge ) )
  raw_dge = as.matrix( raw_dge )[acceptable_genes, seurat_dge@cell.names]
  
  ##Zero-pad to ensure all genes from scale.data are present
  my_zeroes = matrix( 0, ncol = ncol( raw_dge ), nrow = length( missing_genes ) )
  rownames( my_zeroes ) = missing_genes
  colnames( my_zeroes ) = colnames( raw_dge )
  raw_dge = rbind( raw_dge, my_zeroes )
  raw_dge = raw_dge[desired_genes, ]
  
  atae(raw_dge, round( raw_dge ) )
  atae(desired_genes, rownames( raw_dge ) )
  return( raw_dge )
}

#' Merge two Seurat objects.
#' 
SeuratMerge = function( dge1, dge2, vars.keep ){
  dge_all = list( dge1 = deseuratify_raw_data( dge1 ), 
                  dge2 = deseuratify_raw_data( dge2 ) ) %>%
    dge_merge_list %>% seuratify_thy_data 
  if( length(vars.keep) > 0 ){
    preserved_metadata = rbind( FetchDataZeroPad( dge1, vars.keep ), 
                                FetchDataZeroPad( dge2, vars.keep ) )
    dge_all %<>% AddMetaData( preserved_metadata )     
  }
  return(dge_all)
}

## ------------------------------------------------------------------------
#' Merge a list of digital gene expression matrices.
#'
#' @param dge_list list of matrices with genes as rows and cell barcodes as columns. Duplicate barcodes across datasets cause errors; I recommend you append the sample ID.
#' @details `dge_merge_list` converts the digital gene expression matrices to dataframes with genes as columns, merges them, then converts the result back, all without disturbing the gene labels. A gene will be included if it appears in any of the datasets. If a gene appears in one dataset but not another, zeroes will be filled in for missing expression levels.
#'@export
dge_merge_list = function(dge_list){
  # Allow duplicate cells but not duplicate genes
  all_genes = Reduce( f = union, x = lapply( dge_list, rownames ) )
  all_cells = Reduce( f = c,     x = lapply( dge_list, colnames ) )
  if(anyDuplicated(all_cells)){ warning( "Duplicate cell barcodes present." )}
  new_dge = as.data.frame( matrix( 0, nrow = length( all_genes ), 
                                      ncol = length( all_cells ) ) )
  rownames( new_dge ) = all_genes
  colnames( new_dge ) = all_cells
  for( ii in seq_along( dge_list ) ){
    dge = dge_list[[ii]]
    new_dge[rownames(dge), colnames(dge)] = dge
    print( paste( "Finished merging dge matrix", names(dge_list)[[ii]] ) )
  }
  #Results should have at least as many genes as the input with the most genes
  #the number of barcodes should equal the sum of the total barcodes.
  input_dimensions = Reduce(rbind, lapply(dge_list, dim)) %>% matrix(ncol = 2)
  assertthat::assert_that(dim(new_dge)[1] >= max(input_dimensions[,1]))
  assertthat::assert_that(dim(new_dge)[2] == sum(input_dimensions[,2]))
  assertthat::assert_that(!is.null(colnames(new_dge)))
  assertthat::assert_that(!is.null(rownames(new_dge)))
  return( new_dge )
}


## ------------------------------------------------------------------------

#' Given a Seurat object, add information about our experiments.
#'
#' @details It looks in `maehrlab_metadata` for a column named `variable_to_add` and adds that to @data.info with the 
#' name `new_name` (default is `variable_to_add`).
#' It relies on being able to match "Sample_ID" to "orig.ident".
#'@export
add_maehrlab_metadata = function( dge, variable_to_add, new_name = NULL, NA_strings = c("NA", ""),
                                  maehrlab_metadata = thymusatlasdatapublic::get_metadata() ){
  
  unknown_sample = !all(levels( dge@data.info$orig.ident ) %in% maehrlab_metadata[["Sample_ID"]] )
  unknown_var =    !variable_to_add %in% names( maehrlab_metadata ) 
  if( unknown_sample || unknown_var ){
    stop(paste( "Metadata not found. Solutions:\n",
                "1) To list available metadata fields and sample IDs, try     \n",
                "         names(thymusatlasdatapublic::get_metadata())        \n",
                "    or                                                       \n",
                "        thymusatlasdatapublic::get_metadata()[['Sample_ID']] \n",
                "2) the `maehrlab_metadata` argument defaults to `thymusatlasdatapublic::get_metadata()`.\n",
                "    If you have access to thymusatlasdataprivate::get_metadata(), try that instead.") )
  }
  data_by_sample = maehrlab_metadata[[variable_to_add]]
  data_by_sample[ data_by_sample %in% NA_strings ] = NA
  names( data_by_sample ) = maehrlab_metadata[["Sample_ID"]]
  
  # # Expand it to go cell by cell instead of sample by sample; add it to the Seurat object
  new_temp = data_by_sample[ as.character( dge@data.info$orig.ident ) ]
  names( new_temp ) = rownames( dge@data.info )
  if( is.null( new_name ) ){ new_name = variable_to_add }
  dge = Seurat::AddMetaData( dge, metadata = new_temp, col.name = new_name )
  return( dge )
}



