
---
title: "Cleaning the DGE Data"
author: "Eric Kernfeld"
date: "September 7, 2016"
output: html_document
---
```{r}
#' Get available variable names (genes, identity classes, PCA embeddings, etc)
#'
#' @param object Seurat object
#' @return Returns a character vector of all eligible inputs to the `vars.all` argument of `FetchData`.
#' @export
AvailableData = function( object ){
  available_categorized = list( metadata = names( object@data.info ),
                                PCs = names(object@pca.x),
                                tsne = names(object@tsne.rot),
                                ICs = names(object@ica.rot),
                                genes = rownames( object@data ),
                                ident = "ident" )
  return( Reduce( f = union, x = available_categorized ) )
}


#' FetchData but with zeroes for unavailable genes
#'
#' @export
#' @param dge Seurat object
#' @param vars.all List of all variables to fetch. Missing entries are ignored.
#' @param ... Other arguments to pass to FetchData
#'
#' @details This function is stupid: if you ask for "PC1" and it's not available,
#' it will think you're asking for a non-expressed gene, so it will return zeroes.
FetchDataZeroPad = function( dge, vars.all, ... ){
  vars.all = vars.all[complete.cases(vars.all)]
  avail = intersect( vars.all, AvailableData( dge ) )
  unavail = setdiff( vars.all, AvailableData( dge ) )
  to_return  = FetchData( dge,  avail, ... ) 
  pad = as.data.frame( matrix(0,           
                              nrow = nrow( to_return ), 
                              ncol = length( unavail ),
                              dimnames = list( rownames( to_return ),               
                                               unavail) ) )
  to_return = cbind( to_return, pad )
  assertthat::are_equal( sort( vars.all ),   sort( colnames( to_return ) ) )   
  to_return = to_return[, vars.all, drop = F]
  assertthat::assert_that( is.data.frame( to_return ) )
  return( to_return )
}


#' Subset data flexibly from a Seurat object.
#'
#' @param dge Seurat object
#' @param vars.use Variables to fetch for use in `predicate`.
#' @param predicate String to be parsed into an R expression and evaluated as an arg to `base::subset`.
#' @details Calls FetchData, subsets it as a dataframe using base::subset, and 
#' subsets the Seurat object correspondingly (using the df rownames.)
#'
#' @export
#'
SubsetDataFlex = function( dge, vars.use, predicate, zeropad = TRUE ){
  if( typeof(predicate) != "character"){
    print("predicate should be a character vector. It will be parsed into `subset` as an R expression.")
  }
  if(zeropad){
    df = FetchDataZeroPad(dge, vars.use) 
  } else {
    df = FetchData(dge, vars.use) 
  }
  cu = df %>% subset(eval(parse(text=predicate))) %>% rownames
  return( SubsetData(dge, cells.use = cu) )
}


#' Test for markers flexibly from a Seurat object.
#'
#' Calls FindMarkers with extra features.
#'
#' @param ident.use Fetched via FetchData to define the groups being tested. Should obey 
#' @param test.use Passed into FindMarkers unless it is "binomial_batch", in which case 
#'   it uses approximate p-values based on a binomial glmm with a random effect for batch (1|orig.ident). 
#'
#' All other parameters are passed into FindMarkers unless test.use=="binomial_batch", in 
#' which case I attempt to match the behavior of FindMarkers.
#' 
#' Output contains an extra column for q-values from p.adjust(..., method="fdr").
#'
#' @export
#'
FindMarkersFlex = function( object,
                            ident.use, ident.1, 
                            ident.2 = object %>% FetchData(ident.use) %>% extract2(1) %>% unique %>% setdiff(ident.1),
                            order_by_var = "avg_diff",
                            thresh.use = 0.25, 
                            test.use = "binomial_batch",
                            genes.use = object@data %>% rownames,
                            min.pct = 0.1, ... ){
  object %<>% Seurat::SetIdent( ident.use = as.character(FetchData( object, ident.use )[[1]]) )
  predicate = paste0( ident.use, " %in% c( '", ident.1, "', '", paste0(ident.2, collapse = "', '"), "' )" )
  object %<>% SubsetDataFlex( vars.use = ident.use, predicate )
  if( test.use == "binomial_batch" ){
    cat(" \n Computing summaries... \n")
    x = data.frame( gene = genes.use, stringsAsFactors = F )
    rownames( x ) = x$gene
    group_means = aggregate.nice( t(object@data[genes.use,]), by = FetchData(object, ident.use), FUN = mean ) %>% t
    group_pcts  = aggregate.nice( t(object@data[genes.use,]), by = FetchData(object, ident.use), FUN = prop_nz ) %>% t
    x$avg_diff  = group_means[, ident.1] - group_means[, ident.2]
    x$pct.1 = group_pcts[, ident.1]
    x$pct.2 = group_pcts[, ident.2]
    x = subset(x, abs(avg_diff) > thresh.use & ( pct.1 > min.pct | pct.2 > min.pct ) )
    cat(" Computing p-values... \n")
    get_p = function( gene ) {
      data = FetchData(object, c(gene, ident.use, "orig.ident"))
      data[[gene]]  %<>% is_greater_than(0)
      data[[ident.1]] = data[[ident.use]] %in% ident.1
      colnames(data) = make.names(colnames(data))
      mod = lme4::glmer(formula = paste0( colnames(data)[1], " ~ (1|orig.ident) + ", colnames(data)[4] ) , 
                        family = "binomial", data = data )
      mod_p = car::linearHypothesis( mod, hypothesis.matrix = paste0( make.names(ident.1), "TRUE = 0" ) )
      cat(".")
      return( mod_p$`Pr(>Chisq)`[[2]] )
    }
    x$p.value = parallel::mclapply( x$gene, 
                                    function(s) {
                                      tryCatch(get_p(s), error = function(e) NA) 
                                    }) %>% simplify2array()
    failures = is.na(x$p.value)
    cat("    ", sum( failures ), " failed tests out of ", nrow(x), 
        ". Setting failures to 1 for conservative FDR control. \n" )
    x$p.value[failures] = 1
  } else {
    x = Seurat::FindMarkers( object, ident.1 = ident.1, ident.2 = ident.2,                              
                             test.use = test.use,
                             genes.use = genes.use,   
                             thresh.use = thresh.use, 
                             min.pct = min.pct, ... )
  }
  x %<>% (plyr::rename)(c("p_val" = "p.value"))
  if( !is.null( x$p.value ) ){
    x$q.value = p.adjust( x$p.value, method = "fdr" )
  }
  x = x[order(x[[order_by_var]], decreasing = T), ]
  x$gene = rownames(x)
  return( x )
}


```

