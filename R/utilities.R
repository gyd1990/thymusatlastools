## ------------------------------------------------------------------------


library(enrichR)
library(grid)
library(gridExtra)
library(colorspace)
library(Seurat)
library(ggplot2)
library(reshape2)
library(dplyr)
library(magrittr)
library(reshape)
library(monocle)
library(hexbin)
library(cluster)
library(mgcv)
library(destiny)
assertthat::assert_that( packageVersion("destiny") >= "2")
if( packageVersion("ggplot2") < "2.2.1.9000" ) { 
  warning("You may need the development version of ggplot2 if you want the 
          `overplot_adjust=T` option in `custom_feature_plot` to work.")
}

#' Return df with handpicked genes.
#' 
#'@export
get_rene_markers = function(){
  data("handpicked_markers")
  return( handpicked_markers )
}

#' Return a table of genes generated by head-to-head comparison of cTECs and mTECs on the Atlas data.
#'
#'@export
get_cTEC_mTEC_genes = function(){
  data(cTEC_mTEC_data_driven)
  return( cTEC_mTEC_data_driven )
}

#' Return human receptor-ligand pairs from Ramilowski et al 2015.
#'
#'@export
get_ramilowski = function(){
  data(ramilowski)
  return( ramilowski )
}

#' Return cell-cycle genes from original Drop-seq paper by Macosko et al. (2015)
#'
#'@export
get_macosko_cc_genes = function( case = "Capital" ){
  data(cc_genes)
  return(cc_genes)
}

#' Maehr lab list of mouse transcription factors.
#'
#'@export
get_mouse_tfs = function(){
  data(mouse_tfs)
  return( mouse_tfs )
}

#' Poised genes from Lesch 2016 Nature Genetics
#'
#'@export
get_poised_genes = function(){
  data(poised_genes)
  return( poised_genes )
}

#' Human-mouse ortholog pairs from Ensembl 87.
#'
#'@export
get_ortholog_table = function(){
  data( orthologs_ens87 )
  return( orthologs_ens87 )
}

CC_PHASES = c("IG1.S", "S", "G2.M", "M", "M.G1")
black_white = c( colorspace::sequential_hcl( 30, h = 0,   c. = c(0, 0),     l = c( 0, 100  ) ) )
blue_gray_red  = colorspace::diverge_hcl   ( 30,          c = 180,          l = c( 40, 80  ) )
blue_purple_red = colorRampPalette(c("blue", "red"))(30) 
yellow_red  = c( colorspace::sequential_hcl( 18, h = 60,  c. = c(100, 100), l = c( 100, 80 ) ),
                 colorspace::sequential_hcl( 12, h = 0,   c. = c(100, 160), l = c( 80, 40  ) ) )
blue_yellow = c( colorspace::sequential_hcl( 15, h = 260, c. = c(50, 0),    l = c( 13, 65 ) ), 
                 colorspace::sequential_hcl( 15, h = 40,  c. = c(0, 80),    l = c( 65, 95 ) ) )
Thanksgiving_colors = c("yellow", "orange", "red", "brown")

## ------------------------------------------------------------------------
  
atat = function(my_ass) (assertthat::assert_that(my_ass))
atae = function(x, y, ...) (assertthat::are_equal(x, y, ...))

#' Return a scatterplot, labeling outliers.
#'
#'@details This function plots two variables, labeling the ones that are far from their neighbors.
#' `data` should be a dataframe with first column to go on the horizontal axis,
#'    second on the vertical. The third column is treated as the labels and the
#'    fourth (optional) is treated as the color.
#' `main` shows up as the figure title.
#' The proportion of points labeled is `prop_label`.
#' @return Prints and returns a ggplot object.
#' @export
outlier_labeled_scatterplot = function( data, main = "", prop_label = 0.02 ){
  
  # sanitize input
  if(any(is.na(data))){
    cc = complete.cases( data )
    warning(c("Removing ", sum(1-cc), " rows with missing data."))
    data = data[cc, ]
  }
  
  cc = is.finite(data[, 1]) & is.finite(data[, 1]) 
  if(any(!cc)){
    warning(c("Removing ", sum(1-cc), " rows with NaN, Inf, or -Inf."))
    data = data[cc, ]
  }

  
  x = names(data)[[1]]
  y = names(data)[[2]]
  label = names(data)[[3]]
  colour = NULL
  if( length( data ) > 3 ){ colour = names(data)[[4]] }
  data$dist_to_nn = rowSums( FNN::get.knn( data = apply(X = data[ , 1:2 ], MARGIN = 2, FUN = div_by_max ),
                                           k=3, algorithm=c( "cover_tree" ) )$nn.dist )
  data$should_label = data$dist_to_nn > quantile( data$dist_to_nn, probs = (1 - prop_label))
  
  p = ggplot() + ggtitle( main ) +
    geom_text(  data = subset( data,  should_label ),
                aes_string( x = x, y = y, colour = colour, label = label ) ) +
    geom_point( data = subset( data, !should_label ),
                aes_string( x = x, y = y, colour = colour ) )
  print( p )
  return( p )
}

distance_sq = function( x, y ) { sum( ( x - y )^2 ) }
nnz = function(x)(sum(x>0))
#' @export
prop_nz = function(x)( nnz(x) / length(x))

#' @export
div_by_max = function( x ){ return( x / max( x ) ) }
#' @export
div_by_sum = function( x ){ return( x / sum( x ) ) }
#' @export
percentify = function( x ){ return( 100*round( div_by_sum( x ), 3 ) ) }
#' @export
standardize = function( x, nonpar = F ){
  if(nonpar){
    y = x - median(x)
    fake_sd = IQR( y ) / 1.37
    z = y / fake_sd
  } else {
    y = x - mean(x)
    z = y / sd( y )
  }
  return( z )
}

# # Given a matrix, scatterplots all pairs of columns.
#' @export
plot_pairs = function( X, main = "" ){
  D = ncol( X )
  for( ii in 1:D ){
    for( jj in 1:ii ){
      # linear_index = (ii - 1)*D + jj
      if( ii == jj ){
        # could do histogram here, but I don't want to
      } else {
        Y = data.frame( X[[ii]], X[[jj]], rownames( X ) )
        colnames( Y ) = c( colnames( X )[ c(ii, jj) ], "gene" )
        r = cor(Y[, 1], Y[, 2])
        p =  ggplot( Y ) + ggtitle( paste0( main, " (r = ", round(r, 2), ")" ) ) + 
          geom_point( aes_string( x = colnames(Y)[[1]], y = colnames(Y)[[2]] )) 
        print( p ) 
      }
    }
  }
}

#' @export
matrixify_preserving_rownames = function(x) matrix( x,  ncol = 1, dimnames = list( names( x  ), "") )
#' @export
vectorize_preserving_rownames = function(x, i = 1) { v = x[, i]; names(v) = rownames(x); return(v) }
#' @export
down_idx = function(x){ x[[1]] }
#' @export
factor_numeric = function(x) {
  atat(is.numeric(x))
  x = factor(x, levels = sort(unique(x)), ordered = T)
}

# Like dplyr::top_n but it preserves the rownames.
#' @export
top_n_preserve_rownames = function( x, ...){
  if(is.null(rownames(x))){return(top_n(x, ...))}
  rownames_tempcol = make.unique( c( colnames( x ), "rownames_tempcol" ) ) %>% rev %>% down_idx
  x[[rownames_tempcol]] = attr(x, "row.names")
  y = top_n(x, ...)
  attr(y, "row.names") = y[[rownames_tempcol]]
  y[[rownames_tempcol]] = NULL
  return(y)
}
# Make sure an adversarial case -- temp column name already taken -- works out ok
atat( all.equal(  top_n_preserve_rownames(x = data.frame(rownames_tempcol = 10:6), 3, rownames_tempcol), 
                  data.frame(rownames_tempcol = 10:8) ) )

#' Aggregate data.frame by a categorical variable, permissively.
#'
#' @details A wrapper for aggregate(). Accepts atomic "by" argument.
#' Guaranteed to return a dense dataframe. Also returns the aggregation levels in the rownames 
#' instead of adding a column for them.
#' @export
aggregate.nice = function(x, by, FUN, ... ) {
  if( typeof( by ) != "list" ){
    by = list ( by )
  } 
  right_type = ( is.atomic(x) | typeof( x ) %in% c( "matrix", "dataframe" ) )
  if( !right_type ){
    x = as.matrix( x )
  }
  result = aggregate( x, by, FUN = function(x) FUN(x, ...) )
  rownames( result ) = as.character( result[, 1] )
  result = result[ , -1, drop = F]
  return( as.matrix( result ) )
}
test1 = data.frame(1:6, 2, 3)
atae( aggregate.nice( test1, letters[1:6], mean ), test1 )
atat( all( aggregate.nice( test1, rep("A", 6), sum ) == matrix( c(21, 12, 18), nrow = 1) ) )

#' Convert a, b, b, a, c, a to 1, 2, 2, 1, 3, 1. Works with any strings alphabetically.
#' 
#' @export
replace_with_int_rank = function(x) as.numeric( as.factor( x ) )
atat(all(replace_with_int_rank(1:5) == 1:5))
atat(all(replace_with_int_rank(c("a", "b", "a", "c", "c")) == c(1, 2, 1, 3, 3)))
atat(all(replace_with_int_rank(c("0", "2", "0", "4", "4")) == c(1, 2, 1, 3, 3)))

#' @export
na2zero = function(df){
    df[is.na(df)] <- 0
    return(df)
}

#' @export
Capitalize = function(s) {paste0(toupper( substring( s, 1, 1 ) ), tolower( substring( s, 2 ) ) )}
#' @export
assertthat::are_equal(Capitalize(c("FOXN1", "PSMB11")), c("Foxn1", "Psmb11") )

#' Turn a named list or vector of strings into a 
#' pipe-separated key-value format: "<name1>=<value1>|<name2>=<value2>|..."
#'
#' @export
collapse_by_name = function(named_list){
  name_eq_element = named_list # preallocate
  for(field in names( named_list ) ){
    name_eq_element[[field]] = paste0(field, "=", named_list[[field]])
  }
  return(paste(name_eq_element, collapse = "|"))
}

#' Remove a suffix if it is present, but if it's absent, avoid damaging the input.
#'
#' @details Not vectorized! Length-1 character vectors please.
#' @export
strip_suffix = function(s, suffix){
  if( !is.atomic( s ) ) { stop( "This function isn't vectorized. Sorry!" ) }
  if( length( s ) != 1 ){ stop( "This function isn't vectorized. Sorry!" ) }
  nc = nchar(s)
  ncs = nchar(suffix)
  if( substring(s, nc + 1 - ncs, nc ) == suffix ){ s = substring(s, 1, nc - ncs ) }
  return(s)
}
atae( strip_suffix("blah.pdf", ".pdf"), "blah")
atae( strip_suffix("blah",     ".pdf"), "blah")

#' Write text to a file
#'
#' @export
text2file = function(filename, vector_of_lines){
  vector_of_lines = as.character(vector_of_lines)
  fileConn<-file(filename)
  writeLines(vector_of_lines, fileConn)
  close(fileConn)
}

#' Create new directories recursively and without a warning if they already exist.
#'
#' @export
dir.create.nice = function(my_dir){
  if( !dir.exists( my_dir ) ){ dir.create( my_dir, recursive = T) }
}

#' Split out folder names and return them in reverse order with "" at the end.
#'
#' @details split_path("/Users/erickernfeld/Dropbox/2016JULY07scRNAseq/") yields:
#' "2016JULY07scRNAseq"      "Dropbox"            "erickernfeld"       "Users"      ""
#' @export
split_path = function(path) {
  if (dirname(path) %in% c(".", path)) return(basename(path))
  return(c(basename(path), split_path(dirname(path))))
}

#' Take in a function from one finite set of strings to another
#' in the form of a named vector `map`. (Inputs are names, outputs are values.)
#' Return its preimage as a named list of vectors.
#'
#' @details If `detailed_output`, returns a list with named elements:
#'   - `preimage`: a list where each name is an output (a value of `map`)
#'       and each element is a vector of all inputs leading to that output.
#'   - `output_occurs_multiple`: a named list or vector subsetted from `map` 
#'       where each element occurs more than once.
#'   - `output_occurs_once`: a named list or vector subsetted from `map` where 
#'       each element occurs once.
#' Otherwise, it returns just the preimage.
#' @export
get_preimage = function( map, detailed_output = F ){
  if( any( is.na( map ) ) ) { warning( "I haven't tested this on missing values." ) }
  # # Preallocate. Empty lists are treacherous bastards, so fill in NA's at first.
  range_of_map = unique( map )
  preimage = setNames( as.list( rep(NA, length( range_of_map ) ) ), nm = range_of_map )
  
  # # Save CPU time by setting the easy ones wholesale
  output_occurs_multiple = map[ map %in% map[ duplicated( map ) ] ]
  output_occurs_once = map[ !( map %in% output_occurs_multiple ) ]
  preimage[ output_occurs_once ] = names( output_occurs_once )
  
  # # Fill in fibers
  for( input in names( output_occurs_multiple ) ){
    preimage[[ map[[ input ]]  ]] = c( preimage[[ map[[ input ]]  ]], input )
  }
  # # Clean up NA's one by one
  remove_NA = function( x ){ x[!is.na(x)] }
  preimage = lapply( preimage, FUN = remove_NA )
  atae( length( output_occurs_once ), 
        length( unique( output_occurs_once ) ) )
  if(!detailed_output){ return( preimage ) }
  return( list( preimage = preimage, 
                output_occurs_multiple = output_occurs_multiple, 
                output_occurs_once = output_occurs_once ) )
}
atae( get_preimage( map = setNames( LETTERS, letters) ), as.list( setNames( letters, LETTERS) )  )
atae( get_preimage( map = setNames(      c("A", "B", "DUPE", "DUPE"), 
                                         nm = c("a", "b", "c",    "d") ) ), 
      list(A = "a", 
           B = "b",
           DUPE = c( "c", "d" ) ) ) 

## ------------------------------------------------------------------------
# # Set up data on human-mouse orthologs
ortholog_table = get_ortholog_table()
# # Hash tables for fast access 
human_dupes = duplicated( ortholog_table$humansym )
mouse_dupes = duplicated( ortholog_table$mousesym )
h2m = setNames( ortholog_table$mousesym, nm = ortholog_table$humansym )[!human_dupes]
m2h = setNames( ortholog_table$humansym, nm = ortholog_table$mousesym )[!mouse_dupes]

#' Return the ortholog of a given gene or NA (if no match).
#' Human and mouse only.
#'
#' @export
get_ortholog = function( gene, from = "human", to = "mouse" ){
  if       ( from == "human" && to == "mouse"){
    return( h2m[ gene ] )
  } else if( from == "mouse" && to == "human"){
    return( m2h[ gene ] )
  } else {
    warning(' The only working options are from = "human", to = "mouse" and from = "mouse", to = "human". Returning your gene unaltered. ')
    return( gene )
  }
}

#' Same as get_ortholog but returns just T or F.
#'
#' @export
has_ortholog = function( ... ){ !is.na( get_ortholog( ... ) ) }


#' Convert a raw digital gene expression matrix from one species to another.
#'
#'@details If two genes have the same ortholog, the molecule counts get added.
#' If a gene has no ortholog, it is omitted.
#' The input must be a matrix with genes stored in rownames( raw_dge ).
#' @export
convert_species_dge = function( raw_dge, from = "human", to = "mouse"){
  cat( paste( "Converting to", to, "...\n" ) )
  genes = rownames(raw_dge) 
  eligible_genes = genes[ has_ortholog( genes, from, to ) ]
  genes_by_ortholog = eligible_genes %>% get_ortholog( ., from, to ) %>% get_preimage
  raw_dge_converted = matrix( 0, nrow = length( genes_by_ortholog ), ncol = ncol( raw_dge ) )
  rownames( raw_dge_converted ) = names( genes_by_ortholog )
  colnames( raw_dge_converted ) = colnames( raw_dge )
  for( ortholog in names( genes_by_ortholog ) ){
    raw_dge_converted[ ortholog, ] = raw_dge[ genes_by_ortholog[[ortholog]], , drop = F ] %>% colSums
  }
  return( raw_dge_converted )
}

#' Remove species-specific genes from a Seurat object.
#'
#'@details The input is a Seurat object with a metadata field "species".
#' Removes genes that appear in less than 3 out of 1000 cells of any species
#' Also removes genes where the proportion in one species is higher by 0.5 than the other.
#' @export
remove_species_specific_genes = function( dge, results_path, threshold = 0.003, diff_thresh = 0.5 ){
  
  proportions_by_species = aggregate.nice( x   = as.matrix( t( dge@data > 0 ) ), 
                                           by  = dge@data.info$species , 
                                           FUN = mean )
  min_proportions_by_species = sapply( X = proportions_by_species, FUN = min)
  max_proportions_by_species = sapply( X = proportions_by_species, FUN = max)
  
  plot_df = as.data.frame( t( proportions_by_species ) ); names ( plot_df ) = rownames( proportions_by_species )
  plot_df$gene = rownames( plot_df )
  plot_df$diff_big = ( max_proportions_by_species - min_proportions_by_species > diff_thresh )
  plot_df$absent_in_one =  ( min_proportions_by_species < threshold )
  plot_df$excluded = plot_df$absent_in_one | plot_df$diff_big

  pdf( file.path( results_path, "min_proportions_by_species.pdf" ) )
  {
    hist( unlist( min_proportions_by_species[min_proportions_by_species < 10*threshold ] ), 
          main = "Min proportions truncated at 10*threshold",
          xlab = "Proportion in mouse or human (whichever is lower)")
    p = ggplot() + ggtitle("Proportion of cells expressing each gene") +
      geom_point( data = subset( plot_df, !diff_big | absent_in_one ),
                  aes_string( x = names ( plot_df )[1],
                              y = names ( plot_df )[2],
                              colour = "excluded" ) ) +
      geom_text( data = subset( plot_df, diff_big & !absent_in_one ), 
                 aes_string( x = names ( plot_df )[1],
                             y = names ( plot_df )[2],
                             label = "gene", 
                             colour = "excluded" ) )
    print( p )
  } 
  dev.off()

  passing_genes = plot_df$gene[ !plot_df$excluded ]
  print( paste0( "Removing ", 100*round( mean( plot_df$excluded ), 2), "% of the genes." ) )
  if( !is.null( dge@data       ) ) { dge@data       = dge@data      [passing_genes, ]}
  if( !is.null( dge@raw.data   ) ) { dge@raw.data   = dge@raw.data  [passing_genes, ]}
  if( !is.null( dge@scale.data ) ) { dge@scale.data = dge@scale.data[passing_genes, ]}
  if( !is.null( dge@mean.var   ) ) { dge@mean.var   = dge@mean.var  [passing_genes, ]}
  if( !is.null( dge@var.genes   ) ) { dge@var.genes %<>% intersect(  passing_genes )}
  return( dge )
}

