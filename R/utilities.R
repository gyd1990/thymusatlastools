## ------------------------------------------------------------------------

PATH_TO_DATA = file.path( "Data" )
PATH_TO_METADATA = file.path( PATH_TO_DATA, "metadata.csv")
PATH_TO_TABLES = file.path( "tables" ) 

library(enrichR)
library(grid)
library(gridExtra)
library(colorspace)
library(Seurat)
library(ggplot2)
library(reshape2)
library(dplyr)
library(magrittr)
library(reshape)
library(monocle)
library(hexbin)
library(cluster)
library(mgcv)
library(destiny)
assertthat::assert_that( packageVersion("destiny") >= "2")
if( packageVersion("ggplot2") < "2.2.1.9000" ) { 
  warning("You may need the development version of ggplot2 if you want the 
          `overplot_adjust=T` option in `custom_feature_plot` to work.")
}


get_rene_markers = function(){
  markers_df = read.csv( file.path( PATH_TO_TABLES, "cell_type_markers.csv" ), stringsAsFactors = T )
  if( !all( markers_df$marker == Capitalize( markers_df$marker ) ) ){
    warning( paste0( "Not all genes in ", 
                     file.path( PATH_TO_TABLES, "cell_type_markers.csv" ), 
                     " are Capital Case." ) )
  }
  return( markers_df )
}

#' Return a table of genes generated by head-to-head comparison of cTECs and mTECs on the Atlas data.
#'
get_cTEC_mTEC_genes = function(){
  active_genes = read.table( file.path( PATH_TO_TABLES, "cTEC_mTEC_data_driven.txt" ),
                             sep = "\t", stringsAsFactors = F )
  return( active_genes )
}

get_ramilowski = function(){
  ramilowski = read.table( file.path( PATH_TO_TABLES, "LigandReceptor_Ramilowski2015_mouse.txt" ), 
                         header = T, sep="\t", stringsAsFactors = F )
  return( ramilowski )
}

get_macosko_cc_genes = function( case = "Capital" ){
  cc_genes = read.csv( file.path( PATH_TO_TABLES, "Macosko_cell_cycle_genes.txt" ), 
                       sep = "", header = T, stringsAsFactors=FALSE )
  colnames_temp = colnames( cc_genes )
  if( case == "Capital" ){
    cc_genes = apply( cc_genes, MARGIN = 2, FUN = Capitalize )
  } else if ( case == "UPPER" ) {
    cc_genes = apply( cc_genes, MARGIN = 2, FUN = toupper )
  }
  colnames( cc_genes ) = colnames_temp
  return ( cc_genes )
}

get_mouse_tfs = function( capitalization = "all" ){
  mouse_tfs = read.table( file.path( PATH_TO_TABLES, "mouse_tfs.txt" ), header = T )$symbol %>% as.character
  if( capitalization == "all" ){
    mouse_tfs = c( mouse_tfs, Capitalize( mouse_tfs ), toupper( mouse_tfs ) )
  } else if( capitalization == "UPPER" ){
    mouse_tfs =  toupper( mouse_tfs )
  } else if( capitalization == "Capitalized" ){
    mouse_tfs = Capitalize( mouse_tfs )
  } else if( capitalization == "unchanged" ){
    # don't change it!
  }
  return( mouse_tfs )
}

get_poised_genes = function(){
  x = read.table( file.path( PATH_TO_TABLES, "Lesch2016_NatGen_PoisedGenes.txt" ), 
                  header = T, stringsAsFactors = F )
  return( x[["mouse_gene_symbol"]] )
}

get_ortholog_table = function(){
  ortholog_table_path = file.path( PATH_TO_TABLES, "mousegene_matchedHumanOrth.txt" )
  if( !file.exists( ortholog_table_path ) ){
    stop( "Please put a table of human-mouse orthologs at PATH_TO_TABLES/mousegene_matchedHumanOrth.csv. It should be a CSV file with columns named `mousesym` and `humansym` containing mouse and human gene symbols. ")
  }
  return( read.csv( ortholog_table_path, header = T, stringsAsFactors = F ) )
}

get_ATAC_seq = function(){
  the_right_file = "mm9.2.e13.5Embryo_ATAC_summits_350bp_allChroms_regPotential.txt"
  atac = read.table( file.path( PATH_TO_ATAC, the_right_file ), header = T, stringsAsFactors = F )
  # colnames( atac ) = lapply( colnames( atac ), FUN = substring, first = 3)
  ensembl_ids = read.table( file.path( PATH_TO_TABLES, "mouse_genes_ensembl.txt" ),
                            header = T, stringsAsFactors = F, sep = "\t" )
  ensembl_ids = ensembl_ids[!duplicated( ensembl_ids$Gene.ID ), ]
  
  # # Get rid of genes present in only one table or the other
  missing_from_biomart_table = setdiff( rownames( atac ), unique( ensembl_ids$Gene.ID ))
  print( paste0("Discarding ", length( missing_from_biomart_table ),
               " genes that are in Michael's data but not available through BioMart." ) )
  genes_use_ensembl = intersect( rownames( atac ), unique( ensembl_ids$Gene.ID ) )
  atac_convertible = atac[ genes_use_ensembl, ]
  ensembl_ids = subset( ensembl_ids, Gene.ID %in% genes_use_ensembl )

  atat( !any( is.na( atac_convertible ) ) )
  
  my_map = setNames( ensembl_ids$Associated.Gene.Name, nm = ensembl_ids$Gene.ID )
  preimage_info = get_preimage( my_map, detailed_output = T )
  atac_converted_unique = atac_convertible[names( preimage_info$output_occurs_once ), ]
  rownames( atac_converted_unique ) = preimage_info$output_occurs_once 
  atat( !any( is.na( atac_converted_unique ) ) )
  atac_converted_dupes = matrix(NA, 
                                ncol = ncol( atac_converted_unique ), 
                                nrow = length( unique( preimage_info$output_occurs_multiple ) ) )
  colnames( atac_converted_dupes ) = colnames( atac_converted_unique )
  dupe_symbols = unique( preimage_info$output_occurs_multiple ) 
  rownames( atac_converted_dupes ) = dupe_symbols
  
  print( paste0( "Converting ", 
                 length( my_map ),
                 " ensembl ids to only ",
                 length( preimage_info$preimage ),
                 " gene symbols. Colliding rows will be averaged. " ) )
  for( gene_symbol in dupe_symbols ){
    idx = preimage_info$preimage[[ gene_symbol ]]
    atac_converted_dupes[gene_symbol, ] = colMeans( atac_convertible[idx, ])
  }

  atac_converted = rbind( atac_converted_unique, atac_converted_dupes )
  atat( !any( is.na( atac_converted ) ) )

  return( atac_converted )
}

showcol = function(col) { pie(rep(1, length(col)), col = col) }
CC_PHASES = c("IG1.S", "S", "G2.M", "M", "M.G1")
black_white = c( colorspace::sequential_hcl( 30, h = 0,   c. = c(0, 0),     l = c( 0, 100  ) ) )
blue_gray_red  = colorspace::diverge_hcl   ( 30,          c = 180,          l = c( 40, 80  ) )
blue_purple_red = colorRampPalette(c("blue", "red"))(30) 
red_yellow  = c( colorspace::sequential_hcl( 15, h = 0,   c. = c(150, 0),   l = c( 40, 30  ) ),
                 colorspace::sequential_hcl( 15, h = 40,  c. = c(0, 80),    l = c( 30, 80  ) ) )
yellow_red  = c( colorspace::sequential_hcl( 18, h = 60,  c. = c(100, 100), l = c( 100, 80 ) ),
                 colorspace::sequential_hcl( 12, h = 0,   c. = c(100, 160), l = c( 80, 40  ) ) )
blue_yellow = c( colorspace::sequential_hcl( 15, h = 260, c. = c(50, 0),    l = c( 13, 65 ) ), 
                 colorspace::sequential_hcl( 15, h = 40,  c. = c(0, 80),    l = c( 65, 95 ) ) )
human_mouse_vvv_colors = c( "goldenrod4", "lightgoldenrod2", "goldenrod3", "goldenrod1", 
                            "cadetblue4", "blue4", "cadetblue3", "blue1", "cadetblue1", 
                            "firebrick4","deeppink3", "firebrick3","palevioletred1", "firebrick1")
Thanksgiving_colors = c("yellow", "orange", "red", "brown")
imitate_cubehelix = c("#fff6e3",
                      "#ddcac4",
                      "#bca0a6",
                      "#9b7789",
                      "#7b506d",
                      "#5b2a52",
                      "#3c0038")

## ------------------------------------------------------------------------
  
atat = function(my_ass) (assertthat::assert_that(my_ass))
atae = function(x, y, ...) (assertthat::are_equal(x, y, ...))

# This function plots two variables, labeling the ones that are far from their neighbors.
# `data` should be a dataframe with first column to go on the horizontal axis,
#    second on the vertical. The third column is treated as the labels and the
#    fourth (optional) is treated as the color.
# `main` shows up as the figure title.
# The proportion of points labeled is `prop_label`.
# Prints and returns a ggplot object.
outlier_labeled_scatterplot = function( data, main = "", prop_label = 0.02 ){
  
  # sanitize input
  if(any(is.na(data))){
    cc = complete.cases( data )
    warning(c("Removing ", sum(1-cc), " rows with missing data."))
    data = data[cc, ]
  }
  
  cc = is.finite(data[, 1]) & is.finite(data[, 1]) 
  if(any(!cc)){
    warning(c("Removing ", sum(1-cc), " rows with NaN, Inf, or -Inf."))
    data = data[cc, ]
  }

  
  x = names(data)[[1]]
  y = names(data)[[2]]
  label = names(data)[[3]]
  colour = NULL
  if( length( data ) > 3 ){ colour = names(data)[[4]] }
  data$dist_to_nn = rowSums( FNN::get.knn( data = apply(X = data[ , 1:2 ], MARGIN = 2, FUN = div_by_max ),
                                           k=3, algorithm=c( "cover_tree" ) )$nn.dist )
  data$should_label = data$dist_to_nn > quantile( data$dist_to_nn, probs = (1 - prop_label))
  
  p = ggplot() + ggtitle( main ) +
    geom_text(  data = subset( data,  should_label ),
                aes_string( x = x, y = y, colour = colour, label = label ) ) +
    geom_point( data = subset( data, !should_label ),
                aes_string( x = x, y = y, colour = colour ) )
  print( p )
  return( p )
}

distance_sq = function( x, y ) { sum( ( x - y )^2 ) }
nnz = function(x)(sum(x>0))
prop_nz = function(x)( nnz(x) / length(x))

#' Quickly define an aggregator function that works only on positive (or nonzero) elements.
#' 
#' @param FUN function that accepts a numeric vector.
#' @param default If nonzerify(FUN, default) is applied to a list of ineligible elements, it returns this.
#' @param allow_negative If F (default), returned function only acts on positive numbers. Otherwise, all nonzeroes are allowed in.
#' @value A function that returns the result of applying FUN to only the eligible values.
nonzerify = function( FUN, default = 0, allow_negative = F ){
  if( allow_negative ) {
    eligibles = function( x ) (x != 0)
  } else {
    eligibles = function( x ) (x >= 0)
  }
  to_return = function( x ){
    if( all( x==0 ) ){return(0)}
    return( FUN( x[x>0] ) )
  }
}
atae( nonzerify(median)(-1:5), 3)
atae( nonzerify(mean)(-1:5), 3)
atae( nonzerify(prop_nz)(c(0,0,0,4)), 1)

div_by_max = function( x ){ return( x / max( x ) ) }
div_by_sum = function( x ){ return( x / sum( x ) ) }
percentify = function( x ){ return( 100*round( div_by_sum( x ), 3 ) ) }
standardize = function( x, nonpar = F ){
  if(nonpar){
    y = x - median(x)
    fake_sd = IQR( y ) / 1.37
    z = y / fake_sd
  } else {
    y = x - mean(x)
    z = y / sd( y )
  }
  return( z )
}

# # Given a matrix, scatterplots all pairs of columns.
plot_pairs = function( X, main = "" ){
  D = ncol( X )
  for( ii in 1:D ){
    for( jj in 1:ii ){
      # linear_index = (ii - 1)*D + jj
      if( ii == jj ){
        # could do histogram here, but I don't want to
      } else {
        Y = data.frame( X[[ii]], X[[jj]], rownames( X ) )
        colnames( Y ) = c( colnames( X )[ c(ii, jj) ], "gene" )
        r = cor(Y[, 1], Y[, 2])
        p =  ggplot( Y ) + ggtitle( paste0( main, " (r = ", round(r, 2), ")" ) ) + 
          geom_point( aes_string( x = colnames(Y)[[1]], y = colnames(Y)[[2]] )) 
        print( p ) 
      }
    }
  }
}


matrixify_preserving_rownames = function(x) matrix( x,  ncol = 1, dimnames = list( names( x  ), "") )
vectorize_preserving_rownames = function(x, i = 1) { v = x[, i]; names(v) = rownames(x); return(v) }
down_idx = function(x){ x[[1]] }
factor_numeric = function(x) {
  atat(is.numeric(x))
  x = factor(x, levels = sort(unique(x)), ordered = T)
}

# Like dplyr::top_n but it preserves the rownames.
top_n_preserve_rownames = function( x, ...){
  if(is.null(rownames(x))){return(top_n(x, ...))}
  rownames_tempcol = make.unique( c( colnames( x ), "rownames_tempcol" ) ) %>% rev %>% down_idx
  x[[rownames_tempcol]] = attr(x, "row.names")
  y = top_n(x, ...)
  attr(y, "row.names") = y[[rownames_tempcol]]
  y[[rownames_tempcol]] = NULL
  return(y)
}
# Make sure an adversarial case -- temp column name already taken -- works out ok
atat( all.equal(  top_n_preserve_rownames(x = data.frame(rownames_tempcol = 10:6), 3, rownames_tempcol), 
                  data.frame(rownames_tempcol = 10:8) ) )

# # Friendlier version of aggregate(). Accepts atomic "by" argument.
# # Guaranteed to return a dense dataframe. Also returns the aggregation levels in the rownames 
# # instead of adding a fucking column for them.
aggregate.nice = function(x, by, FUN, ... ) {
  if( typeof( by ) != "list" ){
    by = list ( by )
  } 
  right_type = ( is.atomic(x) | typeof( x ) %in% c( "matrix", "dataframe" ) )
  if( !right_type ){
    x = as.matrix( x )
  }
  result = aggregate( x, by, FUN = function(x) FUN(x, ...) )
  rownames( result ) = as.character( result[, 1] )
  result = result[ , -1, drop = F]
  return( as.matrix( result ) )
}
test1 = data.frame(1:6, 2, 3)
atae( aggregate.nice( test1, letters[1:6], mean ), test1 )
atat( all( aggregate.nice( test1, rep("A", 6), sum ) == matrix( c(21, 12, 18), nrow = 1) ) )

replace_with_int_rank = function(x) as.numeric( as.factor( x ) )
atat(all(replace_with_int_rank(1:5) == 1:5))
atat(all(replace_with_int_rank(c("a", "b", "a", "c", "c")) == c(1, 2, 1, 3, 3)))
atat(all(replace_with_int_rank(c("0", "2", "0", "4", "4")) == c(1, 2, 1, 3, 3)))
  
na2zero = function(df){
    df[is.na(df)] <- 0
    return(df)
}

Capitalize = function(s) {paste0(toupper( substring( s, 1, 1 ) ), tolower( substring( s, 2 ) ) )}
assertthat::are_equal(Capitalize(c("FOXN1", "PSMB11")), c("Foxn1", "Psmb11") )

# Turn a named list or vector of strings into a 
# pipe-separated key-value format: "<name1>=<value1>|<name2>=<value2>|..."
collapse_by_name = function(named_list){
  name_eq_element = named_list # preallocate
  for(field in names( named_list ) ){
    name_eq_element[[field]] = paste0(field, "=", named_list[[field]])
  }
  return(paste(name_eq_element, collapse = "|"))
}

# Removes a suffix if it is present without damaging the string when it's not present.
# Not vectorized!
strip_suffix = function(s, suffix){
  if( !is.atomic( s ) ) { stop( "This function isn't vectorized. Sorry!" ) }
  if( length( s ) != 1 ){ stop( "This function isn't vectorized. Sorry!" ) }
  nc = nchar(s)
  ncs = nchar(suffix)
  if( substring(s, nc + 1 - ncs, nc ) == suffix ){ s = substring(s, 1, nc - ncs ) }
  return(s)
}
atae( strip_suffix("blah.pdf", ".pdf"), "blah")
atae( strip_suffix("blah",     ".pdf"), "blah")

text2file = function(filename, vector_of_lines){
  vector_of_lines = as.character(vector_of_lines)
  fileConn<-file(filename)
  writeLines(vector_of_lines, fileConn)
  close(fileConn)
}

dir.create.nice = function(my_dir){
  if( !dir.exists( my_dir ) ){ dir.create( my_dir, recursive = T) }
}

# Splits out the folder names and returns them in reverse order with "" at the end.
# split_path("/Users/erickernfeld/Dropbox/2016JULY07scRNAseq/") yields:
# "2016JULY07scRNAseq"      "Dropbox"            "erickernfeld"       "Users"              ""  
split_path = function(path) {
  if (dirname(path) %in% c(".", path)) return(basename(path))
  return(c(basename(path), split_path(dirname(path))))
}

# # Takes in a function from one finite set of strings to another
# # in the form of a named vector `map`. (Inputs are names, outputs are values.)
# # 
# # If `detailed_output`, returns a list with named elements:
# #   - `preimage`: a list where each name is an output (a value of `map`)
# #       and each element is a vector of all inputs leading to that output.
# #   - `output_occurs_multiple`: a named list or vector subsetted from `map` 
# #       where each element occurs more than once.
# #   - `output_occurs_once`: a named list or vector subsetted from `map` where 
# #       each element occurs once.
# # Otherwise, it returns just the preimage.
get_preimage = function( map, detailed_output = F ){
  if( any( is.na( map ) ) ) { warning( "I haven't tested this on missing values." ) }
  # # Preallocate. Empty lists are treacherous bastards, so fill in NA's at first.
  range_of_map = unique( map )
  preimage = setNames( as.list( rep(NA, length( range_of_map ) ) ), nm = range_of_map )
  
  # # Save CPU time by setting the easy ones wholesale
  output_occurs_multiple = map[ map %in% map[ duplicated( map ) ] ]
  output_occurs_once = map[ !( map %in% output_occurs_multiple ) ]
  preimage[ output_occurs_once ] = names( output_occurs_once )
  
  # # Fill in fibers
  for( input in names( output_occurs_multiple ) ){
    preimage[[ map[[ input ]]  ]] = c( preimage[[ map[[ input ]]  ]], input )
  }
  # # Clean up NA's one by one
  remove_NA = function( x ){ x[!is.na(x)] }
  preimage = lapply( preimage, FUN = remove_NA )
  atae( length( output_occurs_once ), 
        length( unique( output_occurs_once ) ) )
  if(!detailed_output){ return( preimage ) }
  return( list( preimage = preimage, 
                output_occurs_multiple = output_occurs_multiple, 
                output_occurs_once = output_occurs_once ) )
}
atae( get_preimage( map = setNames( LETTERS, letters) ), as.list( setNames( letters, LETTERS) )  )
atae( get_preimage( map = setNames(      c("A", "B", "DUPE", "DUPE"), 
                                    nm = c("a", "b", "c",    "d") ) ), 
      list(A = "a", 
           B = "b",
           DUPE = c( "c", "d" ) ) ) 

## ------------------------------------------------------------------------
# # Set up data on human-mouse orthologs
ortholog_table = get_ortholog_table()
# # Hash tables for fast access 
human_dupes = duplicated( ortholog_table$humansym )
mouse_dupes = duplicated( ortholog_table$mousesym )
h2m = setNames( ortholog_table$mousesym, nm = ortholog_table$humansym )[!human_dupes]
m2h = setNames( ortholog_table$humansym, nm = ortholog_table$mousesym )[!mouse_dupes]

# # This function returns the ortholog of a given gene.
# # If it finds no match, it returns NA.
get_ortholog = function( gene, from = "human", to = "mouse" ){
  if       ( from == "human" && to == "mouse"){
    return( h2m[ gene ] )
  } else if( from == "mouse" && to == "human"){
    return( m2h[ gene ] )
  } else {
    warning(' The only working options are from = "human", to = "mouse" and from = "mouse", to = "human". Returning your gene unaltered. ')
    return( gene )
  }
}
# # Same as get_ortholog but returns just T or F.
has_ortholog = function( ... ){ !is.na( get_ortholog( ... ) ) }


# # This function converts a raw digital gene expression matrix from one species to another.
# # If two genes have the same ortholog, the molecule counts get merged.
# # If a gene has no ortholog, it is omitted.
# # The input must be a matrix with genes stored in rownames( raw_dge ).
convert_species_dge = function( raw_dge, from = "human", to = "mouse"){
  cat( paste( "Converting to", to, "...\n" ) )
  genes = rownames(raw_dge) 
  eligible_genes = genes[ has_ortholog( genes, from, to ) ]
  genes_by_ortholog = eligible_genes %>% get_ortholog( ., from, to ) %>% get_preimage
  raw_dge_converted = matrix( 0, nrow = length( genes_by_ortholog ), ncol = ncol( raw_dge ) )
  rownames( raw_dge_converted ) = names( genes_by_ortholog )
  colnames( raw_dge_converted ) = colnames( raw_dge )
  for( ortholog in names( genes_by_ortholog ) ){
    raw_dge_converted[ ortholog, ] = raw_dge[ genes_by_ortholog[[ortholog]], , drop = F ] %>% colSums
  }
  return( raw_dge_converted )
}

# # The input is a Seurat object with a metadata field "species".
# # Removes genes that appear in less than 3 out of 1000 cells of any species
# # Also removes genes where the proportion in one species is higher by 0.5 than the other.
remove_species_specific_genes = function( dge, results_path, threshold = 0.003, diff_thresh = 0.5 ){
  
  proportions_by_species = aggregate.nice( x   = as.matrix( t( dge@data > 0 ) ), 
                                           by  = dge@data.info$species , 
                                           FUN = mean )
  min_proportions_by_species = sapply( X = proportions_by_species, FUN = min)
  max_proportions_by_species = sapply( X = proportions_by_species, FUN = max)
  
  plot_df = as.data.frame( t( proportions_by_species ) ); names ( plot_df ) = rownames( proportions_by_species )
  plot_df$gene = rownames( plot_df )
  plot_df$diff_big = ( max_proportions_by_species - min_proportions_by_species > diff_thresh )
  plot_df$absent_in_one =  ( min_proportions_by_species < threshold )
  plot_df$excluded = plot_df$absent_in_one | plot_df$diff_big

  pdf( file.path( results_path, "min_proportions_by_species.pdf" ) )
  {
    hist( unlist( min_proportions_by_species[min_proportions_by_species < 10*threshold ] ), 
          main = "Min proportions truncated at 10*threshold",
          xlab = "Proportion in mouse or human (whichever is lower)")
    p = ggplot() + ggtitle("Proportion of cells expressing each gene") +
      geom_point( data = subset( plot_df, !diff_big | absent_in_one ),
                  aes_string( x = names ( plot_df )[1],
                              y = names ( plot_df )[2],
                              colour = "excluded" ) ) +
      geom_text( data = subset( plot_df, diff_big & !absent_in_one ), 
                 aes_string( x = names ( plot_df )[1],
                             y = names ( plot_df )[2],
                             label = "gene", 
                             colour = "excluded" ) )
    print( p )
  } 
  dev.off()

  passing_genes = plot_df$gene[ !plot_df$excluded ]
  print( paste0( "Removing ", 100*round( mean( plot_df$excluded ), 2), "% of the genes." ) )
  if( !is.null( dge@data       ) ) { dge@data       = dge@data      [passing_genes, ]}
  if( !is.null( dge@raw.data   ) ) { dge@raw.data   = dge@raw.data  [passing_genes, ]}
  if( !is.null( dge@scale.data ) ) { dge@scale.data = dge@scale.data[passing_genes, ]}
  if( !is.null( dge@mean.var   ) ) { dge@mean.var   = dge@mean.var  [passing_genes, ]}
  if( !is.null( dge@var.genes   ) ) { dge@var.genes %<>% intersect(  passing_genes )}
  return( dge )
}

